import os
from dotenv import load_dotenv

load_dotenv()

def _get(name: str, default: str = "") -> str:
    return os.getenv(name, default).strip()

def _get_bool(name: str, default: str = "false") -> bool:
    return _get(name, default).lower() in ("1","true","yes","y","on")

def _get_int(name: str, default: str) -> int:
    return int(_get(name, default))

def _get_float(name: str, default: str) -> float:
    return float(_get(name, default))

# =============================================================================
# TELEGRAM SIGNAL SOURCE
# =============================================================================
# Get API credentials from: https://my.telegram.org/apps
TELEGRAM_API_ID = _get_int("TELEGRAM_API_ID", "0")
TELEGRAM_API_HASH = _get("TELEGRAM_API_HASH")
TELEGRAM_CHANNEL = _get("TELEGRAM_CHANNEL")  # Channel username (@name) or ID (-1001234567890)
TELEGRAM_SESSION_STRING = _get("TELEGRAM_SESSION_STRING")  # Generated by generate_session.py
TELEGRAM_PHONE = _get("TELEGRAM_PHONE")  # Only needed for initial auth

# =============================================================================
# BYBIT API
# =============================================================================
BYBIT_API_KEY = _get("BYBIT_API_KEY")
BYBIT_API_SECRET = _get("BYBIT_API_SECRET")
BYBIT_TESTNET = _get_bool("BYBIT_TESTNET", "false")
BYBIT_DEMO = _get_bool("BYBIT_DEMO", "false")  # Demo trading (paper trading)
ACCOUNT_TYPE = _get("ACCOUNT_TYPE", "UNIFIED")  # UNIFIED / CONTRACT

RECV_WINDOW = _get("RECV_WINDOW", "5000")

# =============================================================================
# TRADING PARAMETERS
# =============================================================================
CATEGORY = _get("CATEGORY", "linear")  # linear for USDT perpetual
QUOTE = _get("QUOTE", "USDT").upper()

# FIXED leverage - ignores what signal says!
LEVERAGE = _get_int("LEVERAGE", "10")

# Position sizing: Risk % of equity per trade
# With 10x leverage and 3% risk: margin = 3% equity, notional = 30% equity
RISK_PCT = _get_float("RISK_PCT", "3.0")

# Margin mode: We force ISOLATED (ignore signal's Cross mode)
MARGIN_MODE = _get("MARGIN_MODE", "ISOLATED").upper()  # ISOLATED or CROSS

# =============================================================================
# LIMITS & SAFETY
# =============================================================================
MAX_CONCURRENT_TRADES = _get_int("MAX_CONCURRENT_TRADES", "4")
MAX_TRADES_PER_DAY = _get_int("MAX_TRADES_PER_DAY", "20")
TC_MAX_LAG_SEC = _get_int("TC_MAX_LAG_SEC", "300")  # Skip signals older than 5 min

# Batch limit: Max signals to take within a time window (prevents taking all from same batch)
# Example: SIGNALS_PER_WINDOW=2, SIGNAL_WINDOW_MIN=60 â†’ max 2 new trades per hour
SIGNALS_PER_WINDOW = _get_int("SIGNALS_PER_WINDOW", "2")
SIGNAL_WINDOW_MIN = _get_int("SIGNAL_WINDOW_MIN", "60")  # Window in minutes

# Excluded symbols: Comma-separated list of symbols to skip (e.g., "BTC,ETH,SOL")
# These coins often have position sizes too small for TP splits on Bybit
EXCLUDED_SYMBOLS = [s.strip().upper() for s in _get("EXCLUDED_SYMBOLS", "").split(",") if s.strip()]

# =============================================================================
# ENTRY RULES
# =============================================================================
# Entry timeout: Cancel pending entry after X minutes
ENTRY_EXPIRATION_MIN = _get_int("ENTRY_EXPIRATION_MIN", "7")  # 5-10 min range, use 7

# Entry limit offset: Place limit X% BETTER than signal entry
# For LONG: limit = entry * (1 - offset)  -> slightly lower
# For SHORT: limit = entry * (1 + offset) -> slightly higher
ENTRY_LIMIT_OFFSET_PCT = _get_float("ENTRY_LIMIT_OFFSET_PCT", "0.1")

# Skip if price already moved too far past entry (avoid chasing)
ENTRY_TOO_FAR_PCT = _get_float("ENTRY_TOO_FAR_PCT", "0.5")

# =============================================================================
# STOP LOSS (Dynamic based on HH/LL structure)
# =============================================================================
# SL is placed at the last swing high (short) or swing low (long) + buffer
# Then clamped between SL_MIN_PCT and SL_MAX_PCT

# Maximum SL distance (cap) - protects against too-wide structure
SL_MAX_PCT = _get_float("SL_MAX_PCT", "5.0")

# Minimum SL distance (floor) - prevents too-tight SL from noise
SL_MIN_PCT = _get_float("SL_MIN_PCT", "1.5")

# Buffer added to structure level (protection against wicks)
SL_BUFFER_PCT = _get_float("SL_BUFFER_PCT", "0.5")

# Candle settings for structure detection
SL_CANDLE_INTERVAL = _get("SL_CANDLE_INTERVAL", "60")  # 60 = 1h candles
SL_CANDLE_LOOKBACK = _get_int("SL_CANDLE_LOOKBACK", "20")  # Look back 20 candles

# Legacy fixed SL (used as fallback if structure detection fails)
SL_PCT = _get_float("SL_PCT", "5.0")

# Move SL to breakeven after TP1 hits
MOVE_SL_TO_BE_ON_TP1 = _get_bool("MOVE_SL_TO_BE_ON_TP1", "true")

# =============================================================================
# TAKE PROFIT SPLITS
# =============================================================================
# TP splits: What % of position to close at each TP
# TP1: 15%, TP2: 25%, TP3: 25%, TP4: 25% = 90% total
# Remaining 10% = Runner for trailing stop
TP_SPLITS = [float(x) for x in _get("TP_SPLITS", "15,25,25,25").split(",") if x.strip()]
if sum(TP_SPLITS) > 100.0:
    s = sum(TP_SPLITS)
    TP_SPLITS = [x * 100.0 / s for x in TP_SPLITS]

# =============================================================================
# TRAILING STOP
# =============================================================================
# Start trailing after which TP? (1-4, use 4 = after TP4)
TRAIL_AFTER_TP_INDEX = _get_int("TRAIL_AFTER_TP_INDEX", "4")

# Trailing distance: How far behind price the SL trails
TRAIL_DISTANCE_PCT = _get_float("TRAIL_DISTANCE_PCT", "1.5")

# Enable trailing activation on TP hit
TRAIL_ACTIVATE_ON_TP = _get_bool("TRAIL_ACTIVATE_ON_TP", "true")

# =============================================================================
# POLLING & TIMING
# =============================================================================
POLL_SECONDS = _get_int("POLL_SECONDS", "10")
POLL_JITTER_MAX = _get_int("POLL_JITTER_MAX", "3")

# =============================================================================
# MISC
# =============================================================================
DRY_RUN = _get_bool("DRY_RUN", "true")  # Set to false for live trading!
STATE_FILE = _get("STATE_FILE", "state.json")
LOG_LEVEL = _get("LOG_LEVEL", "INFO").upper()

# =============================================================================
# TELEGRAM ALERTS (for notifications, separate from signal source)
# =============================================================================
TELEGRAM_ALERT_BOT_TOKEN = _get("TELEGRAM_ALERT_BOT_TOKEN")
TELEGRAM_ALERT_CHAT_ID = _get("TELEGRAM_ALERT_CHAT_ID")

# Position P&L thresholds to trigger alerts (e.g., 25,35,50 = alert at -25%, -35%, -50%)
POSITION_ALERT_THRESHOLDS = [float(x) for x in _get("POSITION_ALERT_THRESHOLDS", "25,35,50").split(",") if x.strip()]
